/********************************************************************
  Copyright Draegerwerk AG & Co. KGaA
  Generated by Rhapsody 7.5.1 
  Component:     Core 
  Configuration: ClearCase
  Model Element: Core::Identifier
  File Path:     ../../Core/Interface/Base/Identifier.h
*********************************************************************/

#ifndef Core_Interface_Base_Identifier_H
#define Core_Interface_Base_Identifier_H

#include "ComponentKind.h"
#include <stddef.h>
#include <string>

// we ignore lint warning 1931 for subclass constructors to
// avoid confusion about constants declarations lint
// warning 648 would be caused by declaration of bitmasks.
// This declaration should be checked manually during
// review.
//lint -save -e1931 -e648

namespace Core {
    //## package Core::Interface::Base
    
    //## class Identifier
    // Identifier is responsible for holding a unique value to distiguish elements of components. It must be handled as final class.
    // The Identifier is defined as
    // ComponentKey x GroupKey x TypeKey x ElementKey.
    // 
    // Attention: for GroupIds you must set TypeKey to UndefinedType and ElementKey to 0U. You may use the special constructor for GroupIds
    // 
    class Identifier {
    public :
    
        //## auto_generated
        class ComponentKey;
        
        //## auto_generated
        class ElementKey;
        
        //## auto_generated
        class GroupKey;
        
        //## auto_generated
        class Instance;
        
        //## auto_generated
        class TypeId;
        
        // defines different identifier types
        //#[ type TypeKey
        typedef enum
        {
           UndefinedType,  // this MUST be the first entry in enum definition
           NumericalMeasureType,
           EnumMeasureType,
           NumericalSettingType,
           EnumSettingType,
           WaveformType,
           CommunicationType,
           RawDataType,
           SafetyType,
           TimestampType,
           IntervalType,
           SharedObject,
           Limit  // this MUST be the last entry in enum definition
        } TypeKey;
        //#]
        
        // in addition, all bit amounts must be 32. this will be checked by an static assert in assemblIdentifier
        //#[ type BitNumbers
        typedef enum
        {
           InstanceBitAmount   = 2,
           TypeBitAmount       = 4,
           GroupBitAmount      = 8,  // but one value reserved!
           ElementBitAmount    = 8,
		   ComponentBitAmount  = ComponentKind::ComponentBitAmount
        }
         BitNumbers;
        //#]
        
        //#[ type Offsets
        typedef enum
        {
           ElementKeyOffset    = 0,
           TypeIdOffset        = ElementKeyOffset + ElementBitAmount,
           GroupKeyOffset      = TypeIdOffset + TypeBitAmount,
           ComponentKindOffset = GroupKeyOffset + GroupBitAmount,
           InstanceKeyOffset   = ComponentKindOffset + ComponentBitAmount
        }
         Offsets;
        //#]
        
        // this would not work with 16bit - compilers!!
        //#[ type BitMasks
        typedef enum
                              {
                                 // static casts in this definition should avoid polyspace errors concerning integer range overflow
                                 ElementKeyMask    = static_cast<unsigned int>(1 << ElementBitAmount) - 1,
                                 TypeIdMask        = (static_cast<unsigned int>(1 << TypeBitAmount) - 1) << TypeIdOffset,
                                 GroupKeyMask      = (static_cast<unsigned int>(1 << GroupBitAmount) - 1) << GroupKeyOffset,
                                 InstanceKeyMask   = (static_cast<unsigned int>(1 << InstanceBitAmount) - 1) << InstanceKeyOffset,
                                 ComponentKindMask = (static_cast<unsigned int>(1 << ComponentBitAmount) - 1) << ComponentKindOffset
                              }  BitMasks;
        //#]
        
        // holds identifier type information
        //## class Identifier::TypeId
        class TypeId {
        public :
        
            //## operation TypeId()
            inline TypeId();
            
            //## operation TypeId(TypeId)
            inline TypeId(const TypeId& right);
            
            //## operation ~TypeId()
            inline ~TypeId();
            
            //## operation operator=(TypeId)
            TypeId& operator=(const TypeId& right);
            
            //## operation operator==(TypeId) const
            inline bool operator==(const TypeId& right) const;
            
            //## operation operator!=(TypeId) const
            inline bool operator!=(const TypeId& right) const;
            
            //## operation operator<(TypeId) const
            inline bool operator<(const TypeId& right) const;
            
            //## operation operator>(TypeId) const
            inline bool operator>(const TypeId& right) const;
            
            //## operation operator<=(TypeId) const
            inline bool operator<=(const TypeId& right) const;
            
            //## operation operator>=(TypeId) const
            inline bool operator>=(const TypeId& right) const;
            
            //## operation getInternal() const
            inline TypeKey getInternal() const;
            
            // Prints this. This can be used for debugging purpose.
            //## operation toString(char,size_t) const
            char* toString(char* aBuffer, size_t aBufferLen) const;
        
        private :
        
            TypeKey m_value;		//## attribute m_value
        
        public :
        
            //## operation TypeId(TypeKey)
            TypeId(TypeKey idType);
            
       };
        
        // defines groups in the namespace of a special module
        //## class Identifier::GroupKey
        class GroupKey {
        public :
        
            //#[ type Constants
            typedef enum
            {
               ReservedValue = (1U << GroupBitAmount) - 1,  // don't use! for future extension!
               MaxValue = ReservedValue  - 1,               // 0 .. to this is allowed to use, but MaxValue is reserved for S16
               ReservedForS16 = MaxValue                    // ... for ModuleState identifier
            }
             Constants;
            //#]
            
            //## operation GroupKey()
            inline GroupKey();
            
            //## operation GroupKey(GroupKey)
            inline GroupKey(const GroupKey& right);
            
            // Constructs a GroupKey. The range 0...MaxValue is checked
            // 	(throws an Exception if range is violated). The value
            // 	ReservedValue is reserved for future extension! The
            // 	Value ReservedForS16 is reserved for S16 internal use
            // 	(ModuleState identifier).
            //## operation GroupKey(unsigned short)
            GroupKey(unsigned short id);
            
            //## operation ~GroupKey()
            inline ~GroupKey();
            
            //## operation operator=(GroupKey)
            GroupKey& operator=(const GroupKey& right);
            
            //## operation operator==(GroupKey) const
            inline bool operator==(const GroupKey& right) const;
            
            //## operation operator!=(GroupKey) const
            inline bool operator!=(const GroupKey& right) const;
            
            //## operation operator<(GroupKey) const
            inline bool operator<(const GroupKey& right) const;
            
            //## operation operator>(GroupKey) const
            inline bool operator>(const GroupKey& right) const;
            
            //## operation operator<=(GroupKey) const
            inline bool operator<=(const GroupKey& right) const;
            
            //## operation operator>=(GroupKey) const
            inline bool operator>=(const GroupKey& right) const;
            
            //## operation getInternal() const
            inline unsigned short getInternal() const;
            
            // Prints this. This can be used for debugging purpose.
            //## operation toString(char,size_t) const
            char* toString(char* aBuffer, size_t aBufferLen) const;
        
        private :
        
            unsigned short m_value;		//## attribute m_value
        };
        
        // distinguish group members
        //## class Identifier::ElementKey
        class ElementKey {
        public :
        
            //#[ type Constants
            typedef enum
            {
               MaxValue = (1U << ElementBitAmount) - 1
            } Constants;
            //#]
            
            //## operation ElementKey()
            inline ElementKey();
            
            //## operation ElementKey(ElementKey)
            inline ElementKey(const ElementKey& right);
            
            //## operation ElementKey(unsigned short)
            ElementKey(unsigned short id);
            
            //## operation ~ElementKey()
            inline ~ElementKey();
            
            //## operation operator=(ElementKey)
            ElementKey& operator=(const ElementKey& right);
            
            //## operation operator==(ElementKey) const
            inline bool operator==(const ElementKey& right) const;
            
            //## operation operator!=(ElementKey) const
            inline bool operator!=(const ElementKey& right) const;
            
            //## operation operator<(ElementKey) const
            inline bool operator<(const ElementKey& right) const;
            
            //## operation operator>(ElementKey) const
            inline bool operator>(const ElementKey& right) const;
            
            //## operation operator<=(ElementKey) const
            inline bool operator<=(const ElementKey& right) const;
            
            //## operation operator>=(ElementKey) const
            inline bool operator>=(const ElementKey& right) const;
            
            //## operation getInternal() const
            inline unsigned short getInternal() const;
            
            // Prints this. This can be used for debugging purpose.
            //## operation toString(char,size_t) const
            char* toString(char* aBuffer, size_t aBufferLen) const;
        
        private :
        
            unsigned short m_value;		//## attribute m_value
        };
        
        // distinguish different instances of one module
        //## class Identifier::Instance
        class Instance {
        public :
        
            //#[ type Constants
            typedef enum
            {
               MaxValue = (1U << InstanceBitAmount) - 1
            } Constants;
            //#]
            
            //## operation Instance()
            inline Instance();
            
            //## operation Instance(Instance)
            inline Instance(const Instance& right);
            
            //## operation Instance(unsigned short)
            Instance(unsigned short instanceId);
            
            //## operation ~Instance()
            inline ~Instance();
            
            //## operation operator=(Instance)
            Instance& operator=(const Instance& right);
            
            //## operation operator==(Instance) const
            inline bool operator==(const Instance& right) const;
            
            //## operation operator!=(Instance) const
            inline bool operator!=(const Instance& right) const;
            
            //## operation operator<(Instance) const
            inline bool operator<(const Instance& right) const;
            
            //## operation operator>(Instance) const
            inline bool operator>(const Instance& right) const;
            
            //## operation operator<=(Instance) const
            inline bool operator<=(const Instance& right) const;
            
            //## operation operator>=(Instance) const
            inline bool operator>=(const Instance& right) const;
            
            //## operation getInternal() const
            inline unsigned short getInternal() const;
            
            // Prints this. This can be used for debugging purpose.
            //## operation toString(char,size_t) const
            char* toString(char* aBuffer, size_t aBufferLen) const;
        
        private :
        
            unsigned short m_value;		//## attribute m_value
        };
               
        // Defines ComponentKind x Instance; defines a kind of namespace for a special module instance
        //## class Identifier::ComponentKey
        class ComponentKey {
        public :
        
            //#[ type Constants
            typedef enum
            {
               MaxValue = (1U << (ComponentBitAmount + InstanceBitAmount)) - 1
            } Constants;
            //#]
            
            //## operation ComponentKey()
            inline ComponentKey();
            
            //## operation ComponentKey(ComponentKey)
            inline ComponentKey(const ComponentKey& right);
            
            // the constructors of classes used as parameters will
            // 	check consistency
            //## operation ComponentKey(ComponentKind,Instance)
            ComponentKey(const ComponentKind& componentKind, const Instance& instance);
            
            //## operation ~ComponentKey()
            inline ~ComponentKey();
            
            //## operation operator=(ComponentKey)
            ComponentKey& operator=(const ComponentKey& right);
            
            //## operation operator==(ComponentKey) const
            inline bool operator==(const ComponentKey& right) const;
            
            //## operation operator!=(ComponentKey) const
            inline bool operator!=(const ComponentKey& right) const;
            
            //## operation operator<(ComponentKey) const
            inline bool operator<(const ComponentKey& right) const;
            
            //## operation operator>(ComponentKey) const
            inline bool operator>(const ComponentKey& right) const;
            
            //## operation operator<=(ComponentKey) const
            inline bool operator<=(const ComponentKey& right) const;
            
            //## operation operator>=(ComponentKey) const
            inline bool operator>=(const ComponentKey& right) const;
            
            //## operation getInternal() const
            inline unsigned short getInternal() const;
            
            //## operation getInstance() const
            inline Instance getInstance() const;
            
            //## operation getComponentKind() const
            inline ComponentKind getComponentKind() const;
            
            // Prints this. This can be used for debugging purpose.
            //## operation toString(char,size_t) const
            char* toString(char* aBuffer, size_t aBufferLen) const;
        
        private :
        
            unsigned short m_value;		//## attribute m_value
        };
        
        //## operation Identifier()
        inline Identifier();
        
        //## operation Identifier(Identifier)
        inline Identifier(const Identifier& right);
        
        // DO NOT USE THIS CONSTRUCTOR!!
        // 
        // 	this constructor is for restructure purposes only
        //## operation Identifier(unsigned int)
        explicit inline Identifier(unsigned int identifier);
        
        //## operation ~Identifier()
        inline ~Identifier();
        
        //## operation operator=(Identifier)
        Identifier& operator=(const Identifier& right);
        
        //## operation operator==(Identifier) const
        inline bool operator==(const Identifier& right) const;
        
        //## operation operator!=(Identifier) const
        inline bool operator!=(const Identifier& right) const;
        
        //## operation operator<(Identifier) const
        inline bool operator<(const Identifier& right) const;
        
        //## operation operator>(Identifier) const
        inline bool operator>(const Identifier& right) const;
        
        //## operation operator<=(Identifier) const
        inline bool operator<=(const Identifier& right) const;
        
        //## operation operator>=(Identifier) const
        inline bool operator>=(const Identifier& right) const;
        
        //## operation getComponentKey() const
        inline ComponentKey getComponentKey() const;
        
        //## operation getCombinedGroupKey() const
        inline unsigned int getCombinedGroupKey() const;
        
        //## operation getCombinedGroupId() const
        inline Identifier getCombinedGroupId() const;
        
        //## operation getGroupKey() const
        inline GroupKey getGroupKey() const;
        
        //## operation getTypeId() const
        inline TypeId getTypeId() const;
        
        //## operation getElementKey() const
        inline ElementKey getElementKey() const;
        
        // return the internal stored value
        //## operation getInternal() const
        inline unsigned int getInternal() const;
        
        // The standard constructor creates Identifiers with unique
        // 	Id 0. We define this initial Identifiers as invalid. All
        // 	other constructions should create a valid Identifier.
        //## operation isValid() const
        inline bool isValid() const;
        
        // Prints this. This can be used for debugging purpose.
        //## operation toString(char,size_t) const
		std::string toString() const;
    
    protected :
    
        // constructor, the parameter constructors check the range
        // 	component < MaxSizeOfComponents &
        // 	group < MaxSizeOfGroups &
        // 	type < Limit &
        // 	element < MaxSizeOfElements &
        // 	instance < MaxSizeOfComponentInstances
        //## operation Identifier(ComponentKey,GroupKey,TypeId,ElementKey)
        inline Identifier(const ComponentKey& component, const GroupKey& group, const TypeId& type, const ElementKey& element);
        
        //## operation checkunsigned intConsistency(unsigned int,TypeKey)
        static unsigned int checkUInt32Consistency(unsigned int toCheck, TypeKey expectedType);
        
        // Same behaviour as checkunsigned intConsistency but it throws
        // 	PackingExceptions instead Exception. This method is for
        // 	TypedIdentiffier::unpack only.
        //## operation checkAndAssignunsigned int(unsigned int,TypeKey)
        void checkAndAssignUInt32(unsigned int toCheck, TypeKey expectedType);
    
    private :
    
        //## operation checkunsigned intConsistency(unsigned int)
        static unsigned int checkUInt32Consistency(unsigned int toCheck);
        
        unsigned int m_uniqueId;		//## attribute m_uniqueId
        
        // utility
        //## operation assembleIdentifier(ComponentKey,GroupKey,TypeId,ElementKey)
        inline static unsigned int assembleIdentifier(const ComponentKey& component, const GroupKey& group, const TypeId& type, const ElementKey& element);
    };
    
    inline Identifier::TypeId::TypeId() : m_value (Identifier::UndefinedType) 
      {
        //#[ operation TypeId()
        //#]
    }
    
    inline Identifier::TypeId::TypeId(const Identifier::TypeId& right) : m_value (right.m_value) 
      {
        //#[ operation TypeId(TypeId)
        //#]
    }
    
    inline Identifier::TypeId::~TypeId() {
        //#[ operation ~TypeId()
        //#]
    }
    
    inline bool Identifier::TypeId::operator==(const Identifier::TypeId& right) const {
        //#[ operation operator==(TypeId) const
        return (m_value == right.m_value);
        //#]
    }
    
    inline bool Identifier::TypeId::operator!=(const Identifier::TypeId& right) const {
        //#[ operation operator!=(TypeId) const
        return (m_value != right.m_value);
        //#]
    }
    
    inline bool Identifier::TypeId::operator<(const Identifier::TypeId& right) const {
        //#[ operation operator<(TypeId) const
        return (m_value < right.m_value);
        //#]
    }
    
    inline bool Identifier::TypeId::operator>(const Identifier::TypeId& right) const {
        //#[ operation operator>(TypeId) const
        return (m_value > right.m_value);
        //#]
    }
    
    inline bool Identifier::TypeId::operator<=(const Identifier::TypeId& right) const {
        //#[ operation operator<=(TypeId) const
        return (m_value <= right.m_value);
        //#]
    }
    
    inline bool Identifier::TypeId::operator>=(const Identifier::TypeId& right) const {
        //#[ operation operator>=(TypeId) const
        return (m_value >= right.m_value);
        //#]
    }
    
    inline Identifier::TypeKey Identifier::TypeId::getInternal() const {
        //#[ operation getInternal() const
        
             return m_value;
        
        //#]
    }
    
    inline Identifier::GroupKey::GroupKey() : m_value (0U) 
      {
        //#[ operation GroupKey()
        //#]
    }
    
    inline Identifier::GroupKey::GroupKey(const Identifier::GroupKey& right) : m_value (right.m_value) 
      {
        //#[ operation GroupKey(GroupKey)
        //#]
    }
    
    inline Identifier::GroupKey::~GroupKey() {
        //#[ operation ~GroupKey()
        //#]
    }
    
    inline bool Identifier::GroupKey::operator==(const Identifier::GroupKey& right) const {
        //#[ operation operator==(GroupKey) const
        return (m_value == right.m_value);
        //#]
    }
    
    inline bool Identifier::GroupKey::operator!=(const Identifier::GroupKey& right) const {
        //#[ operation operator!=(GroupKey) const
        return (m_value != right.m_value);
        //#]
    }
    
    inline bool Identifier::GroupKey::operator<(const Identifier::GroupKey& right) const {
        //#[ operation operator<(GroupKey) const
        return (m_value < right.m_value);
        //#]
    }
    
    inline bool Identifier::GroupKey::operator>(const Identifier::GroupKey& right) const {
        //#[ operation operator>(GroupKey) const
        return (m_value > right.m_value);
        //#]
    }
    
    inline bool Identifier::GroupKey::operator<=(const Identifier::GroupKey& right) const {
        //#[ operation operator<=(GroupKey) const
        return (m_value <= right.m_value);
        //#]
    }
    
    inline bool Identifier::GroupKey::operator>=(const Identifier::GroupKey& right) const {
        //#[ operation operator>=(GroupKey) const
        return (m_value >= right.m_value);
        //#]
    }
    
    inline unsigned short Identifier::GroupKey::getInternal() const {
        //#[ operation getInternal() const
        
             return m_value;
        
        //#]
    }
    
    inline Identifier::ComponentKey::ComponentKey() : m_value (0U) 
      {
        //#[ operation ComponentKey()
        //#]
    }
    
    inline Identifier::ComponentKey::ComponentKey(const Identifier::ComponentKey& right) : m_value (right.m_value) 
      {
        //#[ operation ComponentKey(ComponentKey)
        //#]
    }
    
    inline Identifier::ComponentKey::~ComponentKey() {
        //#[ operation ~ComponentKey()
        //#]
    }
    
    inline bool Identifier::ComponentKey::operator==(const Identifier::ComponentKey& right) const {
        //#[ operation operator==(ComponentKey) const
        return (m_value == right.m_value);
        //#]
    }
    
    inline bool Identifier::ComponentKey::operator!=(const Identifier::ComponentKey& right) const {
        //#[ operation operator!=(ComponentKey) const
        return (m_value != right.m_value);
        //#]
    }
    
    inline bool Identifier::ComponentKey::operator<(const Identifier::ComponentKey& right) const {
        //#[ operation operator<(ComponentKey) const
        return (m_value < right.m_value);
        //#]
    }
    
    inline bool Identifier::ComponentKey::operator>(const Identifier::ComponentKey& right) const {
        //#[ operation operator>(ComponentKey) const
        return (m_value > right.m_value);
        //#]
    }
    
    inline bool Identifier::ComponentKey::operator<=(const Identifier::ComponentKey& right) const {
        //#[ operation operator<=(ComponentKey) const
        return (m_value <= right.m_value);
        //#]
    }
    
    inline bool Identifier::ComponentKey::operator>=(const Identifier::ComponentKey& right) const {
        //#[ operation operator>=(ComponentKey) const
        return (m_value >= right.m_value);
        //#]
    }
    
    inline unsigned short Identifier::ComponentKey::getInternal() const {
        //#[ operation getInternal() const
        
             return m_value;
        
        //#]
    }
    
    inline Identifier::Instance Identifier::ComponentKey::getInstance() const {
        //#[ operation getInstance() const
        
             enum
             {
                pattern = (1U << InstanceBitAmount) - 1U
             };
        
             return Instance (static_cast<unsigned short>(m_value & pattern));
        
        //#]
    }
    
    inline ComponentKind Identifier::ComponentKey::getComponentKind() const {
        //#[ operation getComponentKind() const
        return ComponentKind (static_cast<unsigned short>(m_value >> InstanceBitAmount));
        //#]
    }
    
    inline Identifier::ElementKey::ElementKey() : m_value (0U) 
      {
        //#[ operation ElementKey()
        //#]
    }
    
    inline Identifier::ElementKey::ElementKey(const Identifier::ElementKey& right) : m_value (right.m_value) 
      {
        //#[ operation ElementKey(ElementKey)
        //#]
    }
    
    inline Identifier::ElementKey::~ElementKey() {
        //#[ operation ~ElementKey()
        //#]
    }
    
    inline bool Identifier::ElementKey::operator==(const Identifier::ElementKey& right) const {
        //#[ operation operator==(ElementKey) const
        return (m_value == right.m_value);
        //#]
    }
    
    inline bool Identifier::ElementKey::operator!=(const Identifier::ElementKey& right) const {
        //#[ operation operator!=(ElementKey) const
        return (m_value != right.m_value);
        //#]
    }
    
    inline bool Identifier::ElementKey::operator<(const Identifier::ElementKey& right) const {
        //#[ operation operator<(ElementKey) const
        return (m_value < right.m_value);
        //#]
    }
    
    inline bool Identifier::ElementKey::operator>(const Identifier::ElementKey& right) const {
        //#[ operation operator>(ElementKey) const
        return (m_value > right.m_value);
        //#]
    }
    
    inline bool Identifier::ElementKey::operator<=(const Identifier::ElementKey& right) const {
        //#[ operation operator<=(ElementKey) const
        return (m_value <= right.m_value);
        //#]
    }
    
    inline bool Identifier::ElementKey::operator>=(const Identifier::ElementKey& right) const {
        //#[ operation operator>=(ElementKey) const
        return (m_value >= right.m_value);
        //#]
    }
    
    inline unsigned short Identifier::ElementKey::getInternal() const {
        //#[ operation getInternal() const
        
             return m_value;
        
        //#]
    }
    
    inline Identifier::Instance::Instance() : m_value (0U) 
      {
        //#[ operation Instance()
        //#]
    }
    
    inline Identifier::Instance::Instance(const Identifier::Instance& right) : m_value (right.m_value) 
      {
        //#[ operation Instance(Instance)
        //#]
    }
    
    inline Identifier::Instance::~Instance() {
        //#[ operation ~Instance()
        //#]
    }
    
    inline bool Identifier::Instance::operator==(const Identifier::Instance& right) const {
        //#[ operation operator==(Instance) const
        return (m_value == right.m_value);
        //#]
    }
    
    inline bool Identifier::Instance::operator!=(const Identifier::Instance& right) const {
        //#[ operation operator!=(Instance) const
        return (m_value != right.m_value);
        //#]
    }
    
    inline bool Identifier::Instance::operator<(const Identifier::Instance& right) const {
        //#[ operation operator<(Instance) const
        return (m_value < right.m_value);
        //#]
    }
    
    inline bool Identifier::Instance::operator>(const Identifier::Instance& right) const {
        //#[ operation operator>(Instance) const
        return (m_value > right.m_value);
        //#]
    }
    
    inline bool Identifier::Instance::operator<=(const Identifier::Instance& right) const {
        //#[ operation operator<=(Instance) const
        return (m_value <= right.m_value);
        //#]
    }
    
    inline bool Identifier::Instance::operator>=(const Identifier::Instance& right) const {
        //#[ operation operator>=(Instance) const
        return (m_value >= right.m_value);
        //#]
    }
    
    inline Identifier::Identifier(const Identifier& right) : m_uniqueId (right.m_uniqueId) 
      {
        //#[ operation Identifier(Identifier)
        //#]
    }
    
    inline unsigned short Identifier::Instance::getInternal() const {
        //#[ operation getInternal() const
        
             return m_value;
        //#]
    }
    
    inline Identifier::Identifier() : m_uniqueId (0U) 
      {
        //#[ operation Identifier()
        //#]
    }
    
    inline Identifier::Identifier(const Identifier::ComponentKey& component, const Identifier::GroupKey& group, const Identifier::TypeId& type, const Identifier::ElementKey& element) : m_uniqueId (assembleIdentifier (component,
                                                      group,
                                                      type,
                                                      element)) {
        //#[ operation Identifier(ComponentKey,GroupKey,TypeId,ElementKey)
        //#]
    }
    
    inline Identifier::Identifier(unsigned int identifier) : m_uniqueId (checkUInt32Consistency (identifier)) 
      {
        //#[ operation Identifier(unsigned int)
        //#]
    }
    
    inline Identifier::~Identifier() {
        //#[ operation ~Identifier()
        //#]
    }
    
    inline bool Identifier::operator==(const Identifier& right) const {
        //#[ operation operator==(Identifier) const
        return (m_uniqueId == right.m_uniqueId);
        //#]
    }
    
    inline bool Identifier::operator!=(const Identifier& right) const {
        //#[ operation operator!=(Identifier) const
        return (m_uniqueId != right.m_uniqueId);
        //#]
    }
    
    inline bool Identifier::operator<(const Identifier& right) const {
        //#[ operation operator<(Identifier) const
        return (m_uniqueId < right.m_uniqueId);
        //#]
    }
    
    inline bool Identifier::operator>(const Identifier& right) const {
        //#[ operation operator>(Identifier) const
        return (m_uniqueId > right.m_uniqueId);
        //#]
    }
    
    inline bool Identifier::operator<=(const Identifier& right) const {
        //#[ operation operator<=(Identifier) const
        return (m_uniqueId <= right.m_uniqueId);
        //#]
    }
    
    inline bool Identifier::operator>=(const Identifier& right) const {
        //#[ operation operator>=(Identifier) const
        return (m_uniqueId >= right.m_uniqueId);
        //#]
    }
    
    inline Identifier::ComponentKey Identifier::getComponentKey() const {
        //#[ operation getComponentKey() const
        
             return ComponentKey (static_cast<unsigned short>((m_uniqueId & static_cast<unsigned int>(ComponentKindMask)) >> ComponentKindOffset),
                                  static_cast<unsigned short>((m_uniqueId & static_cast<unsigned int>(InstanceKeyMask))   >> InstanceKeyOffset));
        
        //#]
    }
    
    inline unsigned int Identifier::getCombinedGroupKey() const {
        //#[ operation getCombinedGroupKey() const
        
             enum
             {
                CombinedGroupKeyMask = ComponentKindMask | InstanceKeyMask | GroupKeyMask
             };
        
             return m_uniqueId & static_cast<unsigned int>(CombinedGroupKeyMask);
        
        //#]
    }
    
    inline Identifier Identifier::getCombinedGroupId() const {
        //#[ operation getCombinedGroupId() const
        
             return Identifier (getCombinedGroupKey ());
        //#]
    }
    
    inline Identifier::GroupKey Identifier::getGroupKey() const {
        //#[ operation getGroupKey() const
        
             return GroupKey (static_cast<unsigned short>((m_uniqueId & static_cast<unsigned int>(GroupKeyMask)) >> GroupKeyOffset));
        
        //#]
    }
    
    inline Identifier::TypeId Identifier::getTypeId() const {
        //#[ operation getTypeId() const
        
             return TypeId (static_cast<TypeKey>((m_uniqueId & static_cast<unsigned int>(TypeIdMask)) >> TypeIdOffset));
        
        //#]
    }
    
    inline Identifier::ElementKey Identifier::getElementKey() const {
        //#[ operation getElementKey() const
        
             return ElementKey (static_cast<unsigned short>((m_uniqueId & static_cast<unsigned int>(ElementKeyMask)) >> ElementKeyOffset));
        
        //#]
    }
    
    inline unsigned int Identifier::getInternal() const {
        //#[ operation getInternal() const
        
             return m_uniqueId;
        
        //#]
    }
    
    inline bool Identifier::isValid() const {
        //#[ operation isValid() const
        
             return (getComponentKey ().getComponentKind ().getInternal () != 0U);
        
        //#]
    }
    
    inline unsigned int Identifier::assembleIdentifier(const Identifier::ComponentKey& component, const Identifier::GroupKey& group, const Identifier::TypeId& type, const Identifier::ElementKey& element) {
        //#[ operation assembleIdentifier(ComponentKey,GroupKey,TypeId,ElementKey)
        
             unsigned int uComp  = component.getComponentKind ().getInternal () << Identifier::ComponentKindOffset;
             unsigned int uInst  = component.getInstance ().getInternal ()      << Identifier::InstanceKeyOffset;
             unsigned int uGroup = group.getInternal ()                         << Identifier::GroupKeyOffset;
             unsigned int uType  = type.getInternal ()                          << Identifier::TypeIdOffset;
             unsigned int uElem  = element.getInternal ()                       << Identifier::ElementKeyOffset;
        
             unsigned int uReturn = uComp | uInst | uGroup | uType | uElem;
        
             return uReturn;
        
        //#]
    }
}

//lint -restore

#endif

/********************************************************************
  Copyright Draegerwerk AG & Co. KGaA
  Generated by Rhapsody 7.5.1 
  Component:     Core 
  Configuration: ClearCase
  Model Element: typeToString
  File Path:     ../../Core/Interface/Base/Identifier.cpp
*********************************************************************/

#include "Identifier.h"
#include <exception>
#include <sstream>

namespace Core {
    //## attribute ::Core::Interface::Base::TopLevel.NumberStringSize
    static const unsigned int NumberStringSize = 32U;
    
    //## attribute ::Core::Interface::Base::TopLevel.ErrorTextSize
    static const unsigned int ErrorTextSize = 256U;
    
    //## operation ::Core::Interface::Base::TopLevel.typeToString(Core::Identifier::TypeKey)
    inline static const char * typeToString(Core::Identifier::TypeKey value) {
        //#[ operation ::Core::Interface::Base::TopLevel.typeToString(Core::Identifier::TypeKey)
        switch (value)
        {
           case Identifier::UndefinedType:
              return "UndefinedType";
           case Identifier::NumericalMeasureType:
              return "NumericalMeasureType";
           case Identifier::EnumMeasureType:
              return "EnumMeasureType";
           case Identifier::NumericalSettingType:
              return "NumericalSettingType";
           case Identifier::EnumSettingType:
              return "EnumSettingType";
           case Identifier::WaveformType:
              return "WaveformType";
           case Identifier::CommunicationType:
              return "CommunicationType";
           case Identifier::RawDataType:
              return "RawDataType";
           case Identifier::SafetyType:
              return "SafetyType";
           case Identifier::TimestampType:
              return "TimestampType";
           case Identifier::IntervalType:
              return "IntervalType";
           case Identifier::SharedObject:
              return "SharedObject";
           default:
              return "unknown Identifier type";
        }
        //#]
    }
    
    //## package Core::Interface::Base
    
    //## class Identifier
    //## class Identifier::TypeId
    Identifier::TypeId::TypeId(Identifier::TypeKey idType) : m_value (idType) 
      {
        //#[ operation TypeId(TypeKey)
        
             if (idType >= Identifier::Limit)
             {
                throw std::exception ();
             }
        
        //#]
    }
    
    Identifier::TypeId& Identifier::TypeId::operator=(const Identifier::TypeId& right) {
        //#[ operation operator=(TypeId)
        
             if (this != &right)
             {
                m_value = right.m_value;
             }
        
             return *this;
        
        //#]
    }
    
    char* Identifier::TypeId::toString(char* aBuffer, size_t aBufferLen) const {
        //#[ operation toString(char,size_t) const
        
            
             return aBuffer;
        
        //#]
    }
    
    
    //## class Identifier::GroupKey
    Identifier::GroupKey::GroupKey(unsigned short id) : m_value (static_cast<unsigned short>(id)) 
      {
        //#[ operation GroupKey(unsigned short)
        
             if (id > Identifier::GroupKey::MaxValue)
             {
                throw std::exception ("id range exceeded");
             }
        
        //#]
    }
    
    Identifier::GroupKey& Identifier::GroupKey::operator=(const Identifier::GroupKey& right) {
        //#[ operation operator=(GroupKey)
        
             if (this != &right)
             {
                m_value = right.m_value;
             }
        
             return *this;
        
        //#]
    }
    
    char* Identifier::GroupKey::toString(char* aBuffer, size_t aBufferLen) const {
        //#[ operation toString(char,size_t) const
        
           
        
             return aBuffer;
        
        //#]
    }
    
    //## class Identifier::ElementKey
    Identifier::ElementKey::ElementKey(unsigned short id) : m_value (static_cast<unsigned short>(id)) 
      {
        //#[ operation ElementKey(unsigned short)
        
             if (id > Identifier::ElementKey::MaxValue)
             {
                throw std::exception ("id range exceeded");
             }
        
        //#]
    }
    
    Identifier::ElementKey& Identifier::ElementKey::operator=(const Identifier::ElementKey& right) {
        //#[ operation operator=(ElementKey)
        
             if (this != &right)
             {
                m_value = right.m_value;
             }
        
             return *this;
        
        //#]
    }
    
    char* Identifier::ElementKey::toString(char* aBuffer, size_t aBufferLen) const {
        //#[ operation toString(char,size_t) const
        
           
             return aBuffer;
        
        //#]
    }
    
    Identifier& Identifier::operator=(const Identifier& right) {
        //#[ operation operator=(Identifier)
        
             if (this != &right)
             {
                m_uniqueId = right.m_uniqueId;
             }
        
             return *this;
        
        //#]
    }
    
    void Identifier::checkAndAssignUInt32(unsigned int uint32ToCheck, Identifier::TypeKey expectedType) {
        //#[ operation checkAndAssignUInt32(unsigned int,TypeKey)
        
             m_uniqueId = checkUInt32Consistency (uint32ToCheck,
                                                  expectedType);
        
        //#]
    }
    
    //## class Identifier::Instance
    Identifier::Instance::Instance(unsigned short instanceId) : m_value (instanceId) 
      {
        //#[ operation Instance(unsigned short)
        
             if (instanceId > Identifier::Instance::MaxValue)
             {
                throw std::exception ("id range exceeded");
             }
        
        //#]
    }
    
    Identifier::Instance& Identifier::Instance::operator=(const Identifier::Instance& right) {
        //#[ operation operator=(Instance)
        
             if (this != &right)
             {
                m_value = right.m_value;
             }
        
             return *this;
        
        //#]
    }
    
    char* Identifier::Instance::toString(char* aBuffer, size_t aBufferLen) const {
        //#[ operation toString(char,size_t) const
        
            
        
             return aBuffer;
        
        //#]
    }
    
    unsigned int Identifier::checkUInt32Consistency(unsigned int uint32ToCheck, Identifier::TypeKey expectedType) {
        //#[ operation checkUInt32Consistency(unsigned int,TypeKey)
        
             unsigned int typeInfo     = (uint32ToCheck & TypeIdMask)   >> TypeIdOffset;
             unsigned int groupKeyInfo = (uint32ToCheck & GroupKeyMask) >> GroupKeyOffset;
        
             if (groupKeyInfo > GroupKey::MaxValue)
             {
                
                throw std::exception ();
             }
        
             if (typeInfo != static_cast<unsigned int>(expectedType))
             {
               
                throw std::exception ();
             }
        
             return uint32ToCheck;
        
        //#]
    }
    
    //## class Identifier::ComponentKey
    Identifier::ComponentKey::ComponentKey(const ComponentKind& componentKind, const Identifier::Instance& instance) : m_value ((static_cast<unsigned short>(componentKind.getInternal () << InstanceBitAmount))
                               |
                               instance.getInternal ()) {
        //#[ operation ComponentKey(ComponentKind,Instance)
        //#]
    }
    
    Identifier::ComponentKey& Identifier::ComponentKey::operator=(const Identifier::ComponentKey& right) {
        //#[ operation operator=(ComponentKey)
        
             if (this != &right)
             {
                m_value = right.m_value;
             }
        
             return *this;
        
        //#]
    }
    
    char* Identifier::ComponentKey::toString(char* aBuffer, size_t aBufferLen) const {
        //#[ operation toString(char,size_t) const
        
             char compString[NumberStringSize];
             char instString[NumberStringSize];
        
             
        
             return aBuffer;
        
        //#]
    }
    
    unsigned int Identifier::checkUInt32Consistency(unsigned int uint32ToCheck) {
        //#[ operation checkUInt32Consistency(unsigned int)
        
             unsigned int typeInfo     = (uint32ToCheck & TypeIdMask)   >> TypeIdOffset;
             unsigned int groupKeyInfo = (uint32ToCheck & GroupKeyMask) >> GroupKeyOffset;
        
             if (groupKeyInfo > GroupKey::MaxValue)
             {
                throw std::exception ("GroupKey range exceeded");
             }
        
             if (typeInfo >= Limit)
             {
                
                throw std::exception ();
             }
        
             return uint32ToCheck;
        
        //#]
    }
    
	std::string Identifier::toString() const {
        //#[ operation toString(char,size_t) const
        
			 std::stringstream s;
			 s << m_uniqueId;
          
             return s.str();
        
        //#]
    }
}
